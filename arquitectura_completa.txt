ğŸ§± 1. Fundamentos de Arquitectura Hexagonal
(Ports and Adapters)

ğŸ¯ Objetivo General:

Separar el nÃºcleo del dominio (es decir, la lÃ³gica central del problema que
resuelve nuestra aplicaciÃ³n) de los detalles tÃ©cnicos (como bases de datos,
frameworks, servidores, etc.)

ğŸ” Â¿QuÃ© es el "nÃºcleo del dominio"?

Imagina que estÃ¡s creando una aplicaciÃ³n para manejar pedidos de comida.
El "nÃºcleo del dominio" serÃ­a:
â—â€‹ Saber quÃ© es un pedidoâ€‹
â—â€‹ QuÃ© reglas debe cumplir un pedidoâ€‹
â—â€‹ CÃ³mo calcular el precio totalâ€‹
â—â€‹ QuÃ© estados puede tener (creado, en preparaciÃ³n, entregado)â€‹

Nada de eso tiene que ver con cÃ³mo se guarda en la base de datos, si llega por una
API, o si se imprime en pantalla. Eso es infraestructura. Lo importante es que puedas
razonar sobre tu aplicaciÃ³n como si fueras un chef, no un programador.
Ahora desglosamos los beneficios clave de separar esto como pide la arquitectura
hexagonal:

âœ… 1. Alta testabilidad

Â¿QuÃ© significa?â€‹
Podemos probar fÃ¡cilmente si nuestra lÃ³gica funciona sin tener que conectarnos a una
base de datos o levantar un servidor web.
Ejemplo simple:â€‹
Si tienes una funciÃ³n que calcula el total de un pedido con descuentos, puedes probarla
con un test asÃ­:

Go

â—â€‹ pedido := NuevoPedido([]Item{Pizza, Bebida})
â—â€‹ total := pedido.CalcularTotal()
â—â€‹ assert.Equal(t, 25000, total)

No necesitas guardar nada en la base de datos. Â¡Y eso es bueno!

âœ… 2. Bajo acoplamiento
Â¿QuÃ© significa?â€‹
Cambiar una parte de tu sistema (como el proveedor de correo o la base de datos) no
rompe las otras partes.
Ejemplo simple:â€‹
Hoy envÃ­as un correo de confirmaciÃ³n usando Gmail. MaÃ±ana quieres usar SendGrid. Si
tienes un adaptador que implementa una interfaz EmailSender, puedes cambiar la
implementaciÃ³n sin tocar la lÃ³gica del negocio.
Go

â—â€‹ type EmailSender interface {
EnviarCorreo(destinatario string, mensaje string)

â—â€‹

error
â—â€‹ }

La lÃ³gica del dominio solo sabe que hay un EmailSender, no cÃ³mo funciona por dentro.

âœ… 3. Alta cohesiÃ³n
Â¿QuÃ© significa?â€‹
Cada parte del sistema hace solo lo que le corresponde y lo hace bien.
Ejemplo:
â—â€‹ El dominio se encarga de las reglas del negocio.â€‹
â—â€‹ La capa de infraestructura se encarga de hablar con la base de datos.â€‹
â—â€‹ La capa de entrada (controladores) se encarga de recibir la solicitud del usuario.â€‹

Esto hace que el cÃ³digo sea mÃ¡s ordenado y mÃ¡s fÃ¡cil de entender.

âœ… 4. Independencia de frameworks, bases de datos, y protocolos
Â¿QuÃ© significa?â€‹
Puedes cambiar de tecnologÃ­a sin reescribir todo el sistema.
Ejemplo:
â—â€‹ Puedes cambiar de PostgreSQL a MongoDB solo cambiando un adaptador.â€‹
â—â€‹ Puedes exponer tu sistema como API REST hoy y como gRPC maÃ±ana, sin tocar el
dominio.â€‹
â—â€‹ Incluso podrÃ­as ejecutar tu sistema sin internet, todo en memoria.â€‹

ğŸ“ AnalogÃ­a:
Piensa en una cafetera.
â—â€‹ El dominio es el proceso de hacer cafÃ© (moler, hervir, filtrar).â€‹
â—â€‹ La infraestructura es si usas una cafetera italiana, una prensa francesa o
una mÃ¡quina de cÃ¡psulas.â€‹
â—â€‹ El cafÃ© siempre debe salir bien... sin importar la mÃ¡quina.â€‹

Cuando el dominio estÃ¡ bien separado, puedes:
â—â€‹ Probarlo en aislamientoâ€‹
â—â€‹ Reusarlo en otro entornoâ€‹
â—â€‹ Cambiar la tecnologÃ­a sin miedoâ€‹
â—â€‹ Comprenderlo mejorâ€‹

ğŸ§  2. Componentes Clave

ğŸ§  A. Dominio (Core / NÃºcleo de la AplicaciÃ³n)
El dominio representa la esencia del problema que queremos resolver con
nuestro sistema.â€‹
Es como el â€œcerebroâ€ de la aplicaciÃ³n: toma decisiones, vÃ¡lida reglas y
mantiene la lÃ³gica de negocio.

ğŸ“Œ Regla de oro:

El dominio no debe depender de frameworks, bases de datos,
controladores web, ni servicios externos.

1.

ğŸ§â€â™‚ï¸ Entidades (Entities)

Â¿QuÃ© son?â€‹
Son objetos que tienen identidad propia y que pueden cambiar con el tiempo, pero
siguen siendo los mismos.
Ejemplo:â€‹
Un Usuario puede cambiar su nombre o correo, pero sigue siendo el mismo usuario
por su ID.
Go

type Usuario struct {
ID

string

Nombre string
Email

string

}

Pista para saber si es una entidad:â€‹
Â¿Puedo diferenciar dos objetos por su identidad, aunque su contenido sea igual?
â†’ Es una entidad.

2.

ğŸ¯ Objetos de Valor (Value Objects)

Â¿QuÃ© son?â€‹
Son objetos sin identidad, que se definen solo por sus datos. Son inmutables: una
vez creados, no cambian.
Ejemplos comunes:
â—â€‹ Un correo electrÃ³nico (Email)â€‹
â—â€‹ Una cantidad de dinero (Money)â€‹
â—â€‹ Un rango de fechasâ€‹

Go

type Email struct {
valor string
}

func (e Email) Value() string {
return e.valor
}

3.

ğŸ§± Agregados (Aggregates)

Â¿QuÃ© son?â€‹
Un agregado es un conjunto de entidades y objetos de valor que funcionan como
una unidad.â€‹
Tiene una raÃ­z (root) que es la Ãºnica entrada para modificarlo.
Ejemplo:â€‹
Un Pedido (Order) que contiene:
â—â€‹ Cliente (entidad)â€‹
â—â€‹ Lista de productos (entidades)â€‹

â—â€‹ DirecciÃ³n de envÃ­o (objeto de valor)â€‹

Go

type Pedido struct {
ID

string

Cliente

Cliente

Productos []Producto
Estado

string

}

La clase Pedido es la raÃ­z del agregado. Si quieres cambiar algo del pedido, debes
pasar por ella.

4.

âš–ï¸ Servicios de Dominio

Â¿QuÃ© son?â€‹
Son clases que contienen reglas del negocio que:
â—â€‹ No pertenecen naturalmente a una entidadâ€‹
â—â€‹ Involucran varios objetosâ€‹

Ejemplo:â€‹
CalculadoraDePrecioDeEnvio puede recibir un pedido y calcular su costo de
envÃ­o segÃºn la distancia, peso, etc.
Go

type CalculadoraEnvio struct {}

func (c CalculadoraEnvio) Calcular(pedido Pedido)
float64 {
// lÃ³gica de negocio pura
}

5.

ğŸ“¦ Repositorios (Interfaces)

Â¿QuÃ© son?â€‹
Son interfaces (no implementaciones) que definen cÃ³mo se guarda o recupera un
agregado.
Ejemplo:
Go

type PedidoRepository interface {
Guardar(pedido Pedido) error
BuscarPorID(id string) (*Pedido, error)
}

Importante:
â—â€‹ No contiene lÃ³gica de base de datos.â€‹
â—â€‹ Solo define lo que el dominio necesita saber para funcionar.â€‹

6.

ğŸ­ FÃ¡bricas (Factories)

Â¿QuÃ© son?â€‹
Son clases que encapsulan la lÃ³gica compleja de creaciÃ³n de entidades o agregados.
Â¿Por quÃ© se usan?â€‹
Porque a veces crear un objeto correctamente requiere varios pasos, validaciones o
cÃ¡lculos.
Ejemplo:
Go

type FabricaPedido struct {}

func (f FabricaPedido) CrearPedido(cliente Cliente,
productos []Producto) (Pedido, error) {
// lÃ³gica de validaciÃ³n y creaciÃ³n

}

ğŸ’¡ Todo esto NO debe depender de:
â—â€‹ Bases de datos (PostgreSQL, Mongo, etc.)â€‹
â—â€‹ Frameworks (Gin, Spring, Express)â€‹
â—â€‹ Interfaces de usuarioâ€‹
â—â€‹ Servicios externos (APIs, correos, etc.)â€‹

â€‹

ğŸ§­ B. Capa de AplicaciÃ³n (Use Cases)
Esta capa no contiene reglas de negocio, sino que organiza y coordina
cÃ³mo se usan las reglas que ya existen en el dominio para cumplir con una
tarea especÃ­fica del sistema.

ğŸ“¦ 1. Casos de Uso (Application Services)

Â¿QuÃ© son?â€‹
Son las acciones que el sistema puede realizar. Cada uno representa una operaciÃ³n Ãºtil
desde el punto de vista del usuario o del negocio.
Ejemplo:
â—â€‹ RegisterUser â†’ registra un nuevo usuarioâ€‹
â—â€‹ PlaceOrder â†’ crea un pedidoâ€‹
â—â€‹ SendInvoice â†’ envÃ­a una factura por correoâ€‹

Ejemplo en pseudocÃ³digo:
Go

â—â€‹ type RegisterUserService struct {

â—â€‹

userRepo UserRepository // Output port

â—â€‹

emailSender EmailSender // Output port

â—â€‹ }
â—â€‹
â—â€‹ func (s RegisterUserService) Register(cmd
RegisterUserCommand) error {
â—â€‹

usuario := NuevoUsuario(cmd.Nombre, cmd.Email)

â—â€‹

err := s.userRepo.Guardar(usuario)

â—â€‹

if err != nil {

â—â€‹

return err

â—â€‹

}

â—â€‹

return s.emailSender.EnviarBienvenida(usuario.Email)

â—â€‹ }

ğŸ‘‰ El servicio:
â—â€‹ Crea un usuario usando lÃ³gica del dominioâ€‹
â—â€‹ Guarda el usuario usando un repositorioâ€‹
â—â€‹ EnvÃ­a un correo con un adaptador externoâ€‹

ğŸ§© 2. Input Ports (Puertos de entrada)
Â¿QuÃ© son?â€‹
Son interfaces que definen quÃ© operaciones externas estÃ¡n permitidas en el sistema.â€‹
Los controladores (como REST o GraphQL) llaman a estos puertos para activar casos de
uso.
Ejemplo:
Go

â—â€‹ type RegisterUserInputPort interface {
â—â€‹

Register(cmd RegisterUserCommand) error

â—â€‹ }

Esto permite que cualquier adaptador externo (como una API REST o un mensaje de Kafka)
llame al caso de uso sin depender directamente del servicio.

ğŸ”Œ 3. Output Ports (Puertos de salida)
Â¿QuÃ© son?â€‹
Son interfaces que definen lo que la capa de aplicaciÃ³n necesita que otro sistema haga.

ğŸ‘‰ Se usan para abstraer la infraestructura externa, como:
â—â€‹ Base de datosâ€‹
â—â€‹ EnvÃ­o de correosâ€‹

â—â€‹ Servicios externos (pasarela de pagos, notificaciones)â€‹

Ejemplo:
Go

â—â€‹ type EmailSender interface {
â—â€‹

EnviarBienvenida(email string) error

â—â€‹ }
â—â€‹
â—â€‹ type UserRepository interface {
â—â€‹

Guardar(usuario Usuario) error

â—â€‹ }

ğŸ‘‰ Estos puertos son implementados mÃ¡s tarde por adaptadores (por ejemplo, un
repositorio en PostgreSQL o un servicio SMTP).

ğŸ“¤ 4. DTOs / Requests / Responses
Â¿QuÃ© son?â€‹
Son estructuras de datos simples usadas para transportar informaciÃ³n entre capas.â€‹
Sirven para:
â—â€‹ Recibir datos del mundo externo (input)â€‹
â—â€‹ Devolver resultados (output)â€‹
â—â€‹ Evitar que el dominio tenga que entender cosas del exterior (como formatos JSON,
IDs string, etc.)â€‹

Ejemplo:
Go

â—â€‹ type RegisterUserCommand struct {
â—â€‹

Nombre string

â—â€‹

Email

string

â—â€‹ }
â—â€‹
â—â€‹ type RegisterUserResponse struct {
â—â€‹

UserID string

â—â€‹

Mensaje string

â—â€‹ }

ğŸ§  Â¿Por quÃ© esta separaciÃ³n es Ãºtil?
Compon
ente

Â¿Para quÃ© sirve?

Â¿Ventaja?

Casos
de
uso

Ejecutar acciones completas
del sistema

OrquestaciÃ³n clara

Input
ports

Conectar controladores con la
lÃ³gica

Desacopla presentaciÃ³n y lÃ³gica

Output
ports

Delegar tareas externas (DB,
email, etc.)

Testeable, intercambiable

DTOs

Mover datos de forma segura

Evita fugas de detalles tÃ©cnicos
al dominio

ğŸ§© C. Adaptadores (Infrastructure y Interface)
Esta capa conecta el mundo real (navegadores, bases de datos, redes,
APIs externas) con nuestra aplicaciÃ³n.â€‹
Los adaptadores implementan las interfaces (puertos) que definimos en
el dominio y la aplicaciÃ³n.

ğŸ” Â¿Por quÃ© se llaman â€œadaptadoresâ€?

Porque â€œadaptanâ€ el lenguaje del mundo exterior al lenguaje interno de nuestra
aplicaciÃ³n, y viceversa.â€‹
AsÃ­ como un cargador adapta el enchufe de la pared a tu telÃ©fono.

1ï¸âƒ£ Adaptadores de Entrada (Driving Adapters)

ğŸ‘‰ Son los puntos de entrada de las acciones al sistema.â€‹

Son los encargados de recibir solicitudes del usuario o de otro sistema externo.

Ejemplos comunes:

ğŸ“¡ a. Controladores HTTP (REST, GraphQL)
â—â€‹ Reciben una solicitud HTTP (POST /usuarios)â€‹
â—â€‹ Toman los datos del body y los convierten en un DTOâ€‹
â—â€‹ Llaman al input port (caso de uso)â€‹

Go

func (c *UserController) RegistrarUsuario(w
http.ResponseWriter, r *http.Request) {
var cmd RegisterUserCommand
json.NewDecoder(r.Body).Decode(&cmd)
err := c.inputPort.Register(cmd)
// manejar la respuesta
}

ğŸ–¥ï¸ b. Interfaz grÃ¡fica (UI en desktop o web)
â—â€‹ Un botÃ³n en la pantalla puede llamar al caso de uso internamenteâ€‹
â—â€‹ La lÃ³gica sigue pasando por el input portâ€‹

ğŸ’¬ c. Cola de mensajes (Kafka, RabbitMQ)
â—â€‹ Reciben un evento externo (ej: "NuevoPedidoCreado")â€‹
â—â€‹ Transforman el mensaje en un DTOâ€‹
â—â€‹ Llaman al caso de uso correspondienteâ€‹

2ï¸âƒ£ Adaptadores de Salida (Driven Adapters)

ğŸ‘‰ Son los implementadores de los puertos de salida, que hacen tareas como guardar
en base de datos, enviar correos, o llamar APIs.

Ejemplos comunes:

ğŸ’½ a. Base de datos (PostgreSQL, Mongo, etc.)
â—â€‹ Implementan el UserRepositoryâ€‹
â—â€‹ Traducen un Usuario a una entidad de tablaâ€‹
â—â€‹ Usan SQL, ORM, o consultas para persistir o leerâ€‹

Go

type UserRepositoryPostgres struct {
db *sql.DB
}

func (r *UserRepositoryPostgres) Guardar(usuario
Usuario) error {

_, err := r.db.Exec("INSERT INTO usuarios ...",
usuario.ID, usuario.Nombre, ...)
return err
}

ğŸ“¤ b. Servicios externos (Email, APIs)
â—â€‹ Implementan EmailSenderâ€‹
â—â€‹ Usan un cliente HTTP o SMTP para enviar correosâ€‹

Go

type SMTPSender struct {}

func (s SMTPSender) EnviarBienvenida(email string)
error {
// Llamar a servicio SMTP real
}

ğŸ“¡ c. EnvÃ­o de eventos a colas
â—â€‹ Implementan puertos como EventoPublisherâ€‹
â—â€‹ Publican mensajes a Kafka, RabbitMQ, etc.â€‹

ğŸ”„ ConexiÃ³n: Implementan los puertos definidos antes
Tip
o
de
pu

Lo
implem
enta el...

Ejemplo

ert
o

Inp
ut
Po
rt

Adaptad
or de
entrada

Controller REST llama al
caso de uso

Ou
tp
ut
Po
rt

Adaptad
or de
salida

Repositorio guarda en DB,
servicio de email

ğŸ“ AnalogÃ­a:
Piensa que el dominio y los casos de uso son como una fÃ¡brica.â€‹
Los adaptadores de entrada traen los pedidos a la fÃ¡brica.â€‹
Los adaptadores de salida son las mÃ¡quinas que embalan, entregan o
guardan lo que se produce.

ğŸ§­ 3. SeparaciÃ³n de Capas en Arquitectura Hexagonal
La arquitectura hexagonal organiza el cÃ³digo en capas bien definidas, donde cada una
tiene una responsabilidad especÃ­fica y comunican entre sÃ­ solo mediante interfaces
(puertos).

ğŸ¯ Objetivo:

Mantener el sistema desacoplado, testeable, escalable y fÃ¡cil de mantener.

ğŸ“Š Vista general en forma de capas (de arriba hacia abajo):
None

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
Interface

â”‚

â”‚ â† HTTP, CLI, Kafka, etc.

â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
Application Layer

â”‚

â”‚ â† UseCases + Ports

â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
Domain Layer

â”‚

â”‚ â† Entidades, Servicios,

Repos, VOs
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚

Infrastructure Layer

â”‚ â† DB, APIs, Repos, Gateways

â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ§© 1. Interface Layer (Capa de Entrada)
ğŸ“ Â¿QuÃ© hace?â€‹

Recibe la entrada del "mundo exterior" (usuario, red, CLI, eventos) y la transforma en una
llamada al caso de uso correspondiente.

ğŸ“Œ Ejemplos:

â—â€‹ Controladores HTTP (POST /users)â€‹

â—â€‹ CLI (register-user --name AndrÃ©s)â€‹
â—â€‹ Kafka (UsuarioRegistrado evento)â€‹

ğŸ§  No tiene lÃ³gica de negocio. Solo traduce y delega.

âš™ï¸ 2. Application Layer (Capa de AplicaciÃ³n o Casos de Uso)
ğŸ“ Â¿QuÃ© hace?â€‹

Coordina las operaciones del sistema usando entidades del dominio.

ğŸ“Œ Contiene:

â—â€‹ Casos de uso: RegisterUser, PlaceOrder, etc.â€‹
â—â€‹ Input Ports (interfaces que exponen los casos de uso)â€‹
â—â€‹ Output Ports (interfaces que definen quÃ© necesita el sistema: repos, email, etc.)â€‹

ğŸ”§ No sabe cÃ³mo se envÃ­a un correo o cÃ³mo se guarda en la base de datos. Solo sabe que
necesita hacerlo, usando interfaces.

ğŸ§  3. Domain Layer (Capa del Dominio)
ğŸ“ Â¿QuÃ© hace?â€‹

Contiene la lÃ³gica pura del negocio. Es el corazÃ³n del sistema.

ğŸ“Œ Incluye:

â—â€‹ Entidades: Usuario, Orden, etc.â€‹
â—â€‹ Value Objects: Email, Dinero, etc.â€‹
â—â€‹ Reglas de negocio: validaciones, comportamientoâ€‹
â—â€‹ Interfaces como UserRepository o OrderPolicyâ€‹

âœ… No depende de ninguna librerÃ­a externa.â€‹
âœ… Es la capa mÃ¡s estable.

ğŸ—ï¸ 4. Infrastructure Layer (Capa de Infraestructura)
ğŸ“ Â¿QuÃ© hace?â€‹

Implementa los detalles tÃ©cnicos definidos por los puertos de salida.

ğŸ“Œ Ejemplos:

â—â€‹ Repositorios que usan PostgreSQL, MongoDBâ€‹
â—â€‹ EnvÃ­o de correos con SMTP o SendGridâ€‹
â—â€‹ APIs externas (Stripe, Twilio)â€‹

âš ï¸ Esta capa depende de tecnologÃ­as concretas, pero estÃ¡ fuera del nÃºcleo del
sistema.

ğŸ“ AnalogÃ­a
Imagina una empresa:
â—â€‹ Interface Layer: RecepciÃ³n o sitio web (recibe solicitudes)â€‹
â—â€‹ Application Layer: Gerente que coordina los procesosâ€‹
â—â€‹ Domain Layer: Los expertos o ingenieros que conocen el negocioâ€‹
â—â€‹ Infrastructure Layer: El correo, la fÃ¡brica, el banco â€” herramientas
externas que ayudan, pero no son el corazÃ³nâ€‹

ğŸ”„ ComunicaciÃ³n entre capas

âœ”ï¸ Solo comunican hacia abajo usando interfaces.
Por ejemplo:
â—â€‹ El controlador (interface) llama a un caso de uso (application)â€‹
â—â€‹ El caso de uso utiliza un repositorio o servicio de email (infra) implementando un
puerto de salidaâ€‹

âŒ No se permite que la infraestructura llame directamente al dominio.

ğŸ§© 4. Estructura de Carpetas
JAVA
None
src
â””â”€â”€ main
â””â”€â”€ java
â””â”€â”€ com
â””â”€â”€ tuempresa
â””â”€â”€ tuapp
â”œâ”€â”€ TuAppApplication.java

â† clase principal

(SpringBootApplication)
â”œâ”€â”€ domain

â†

(NÃºcleo)

ğŸ“Œ Capa del Dominio

â”‚

â”œâ”€â”€ model

â† Entidades y Value

â”‚

â”œâ”€â”€ repository

â† Interfaces (puertos) de

â”‚

â””â”€â”€ service

â† Servicios de Dominio

Objects
Repositorios
(reglas complejas)
â”œâ”€â”€ application

â†

(UseCases)

âš™ï¸ Casos de Uso

â”‚

â”œâ”€â”€ port

â† Interfaces (puertos) de

â”‚

â”‚

â”œâ”€â”€ input

â† Input Ports

â”‚

â”‚

â””â”€â”€ output

â† Output Ports

â”‚

â””â”€â”€ usecase

entrada y salida

â† Implementaciones de

casos de uso
â”œâ”€â”€ adapter
(Interface e Infra)

â†

ğŸ”Œ Adaptadores

â”‚

â”œâ”€â”€ in

â† Entradas (driving

â”‚

â”‚

â”œâ”€â”€ web

â† Controladores REST

â”‚

â”‚

â””â”€â”€ cli

â† Opcional: Entrada por

â”‚

â””â”€â”€ out

adapters)
(Spring @RestController)
lÃ­nea de comandos
â† Salidas (driven

adapters)

emails, etc.

â”‚

â”œâ”€â”€ persistence

â† Repositorios JPA

â”‚

â””â”€â”€ external

â† APIs externas, envÃ­o de

â””â”€â”€ config

â†

(Beans, JPA, CORS, Swagger, etc.)

ğŸ§¾ ConfiguraciÃ³n

âœ… Ventajas de esta estructura
â—â€‹ Alta testabilidad: Puedes testear casos de uso sin tocar controladores o la base de
datos.â€‹
â—â€‹ Bajo acoplamiento: Infraestructura reemplazable (JPA, Mongo, Rabbit, etc.).â€‹
â—â€‹ Alta cohesiÃ³n: Cada parte estÃ¡ donde debe estar.â€‹
â—â€‹ FÃ¡cil mantenimiento: Se ubican fÃ¡cilmente los casos de uso, lÃ³gica de dominio y
adaptadores.

C#
None
/MyApp
â”‚
â”œâ”€â”€â”€ MyApp.Domain

# NÃºcleo del dominio (no depende de nada)

â”‚

â”œâ”€â”€ Entities

# Entidades (User, Order, etc.)

â”‚

â”œâ”€â”€ ValueObjects

# Objetos de Valor (Email, Money, etc.)

â”‚

â”œâ”€â”€ Services

# Servicios de dominio (reglas de negocio

puras)
â”‚

â”œâ”€â”€ Repositories

# Interfaces para acceder a entidades

â”‚

â””â”€â”€ Exceptions

# Excepciones especÃ­ficas del dominio

â”œâ”€â”€â”€ MyApp.Application

# LÃ³gica de aplicaciÃ³n (casos de uso)

â”‚

â”œâ”€â”€ UseCases

# Casos de uso (RegisterUser, etc.)

â”‚

â”œâ”€â”€ Ports

# Puertos (interfaces)

â”‚

â”‚

â”œâ”€â”€ Input

# Input ports (definidos por la aplicaciÃ³n)

â”‚

â”‚

â””â”€â”€ Output

# Output ports (ej. IEmailSender,

â”‚

IUserRepository)
â”‚

â”œâ”€â”€ DTOs

# Objetos para intercambio de datos

â”‚

â””â”€â”€ Services

# Servicios de orquestaciÃ³n (coordinaciÃ³n

de UC)
â”‚
â”œâ”€â”€â”€ MyApp.Infrastructure
dominio)

# Adaptadores de salida (hacia afuera del

â”‚

â”œâ”€â”€ Persistence

# ImplementaciÃ³n de Repos (con EF Core /

ADO.NET)
â”‚

â”‚

â”œâ”€â”€ SqlServer

# ConexiÃ³n a SQL Server

â”‚

â”‚

â””â”€â”€ Migrations

# Migraciones si usas EF Core

â”‚

â”œâ”€â”€ Email

# Cliente SMTP o servicios externos

â”‚

â””â”€â”€ Configuration

# Archivos y lÃ³gica de configuraciÃ³n

â”‚
â”œâ”€â”€â”€ MyApp.GUI

# Adaptador de entrada (interfaz grÃ¡fica)

â”‚

â”œâ”€â”€ Views

# Formularios o pantallas (WPF, WinForms)

â”‚

â”œâ”€â”€ ViewModels

# ViewModels si usas MVVM

â”‚

â””â”€â”€ Controllers

# Manejan eventos y llaman a casos de uso

â”‚
â”œâ”€â”€â”€ MyApp.Tests

# Pruebas unitarias

â”‚

â”œâ”€â”€ Domain.Tests

# Pruebas del dominio puro

â”‚

â”œâ”€â”€ Application.Tests

# Pruebas de los casos de uso

â”‚

â””â”€â”€ Integration.Tests

# Pruebas integradas (con infraestructura)

â”‚
â””â”€â”€â”€ MyApp.Shared

# CÃ³digo compartido (utils, constantes,

helpers)

ğŸ§© Dependencias (relaciÃ³n entre capas)
â—â€‹ MyApp.Domain no depende de nada.â€‹
â—â€‹ MyApp.Application depende solo del dominio.â€‹
â—â€‹ MyApp.GUI usa los puertos (Input) definidos en Application.â€‹
â—â€‹ MyApp.Infrastructure implementa los puertos (Output) definidos por
Application y depende de detalles tÃ©cnicos como Entity Framework, ADO.NET
o librerÃ­as SMTP.

ğŸ›  Ejemplo de flujo RegisterUser

1.â€‹ En la GUI, el usuario llena un formulario de registro.â€‹
2.â€‹ El controlador de GUI llama al caso de uso RegisterUser a travÃ©s del
InputPort.â€‹
3.â€‹ RegisterUser orquesta la lÃ³gica y llama al UserRepository (OutputPort).â€‹

4.â€‹ Infrastructure implementa UserRepository y lo conecta a SQL Server.

